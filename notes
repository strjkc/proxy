Reverse Proxy:

Support (MVP):
HTTP/1.1 only
Methods: GET/POST
Upstream: one upstream (no load balancing initially)

Bodies:
Content-Length supported
(Skip chunked request bodies at first)

Responses:
forward status + headers + body as-is
support Content-Length and chunked responses by streaming bytes (no parsing needed)

Skip for now:
HTTPS MITM (donâ€™t do this)
HTTP/2
Full RFC compliance
WebSocket upgrade

Milestone A (6â€“8h): dumb TCP forwarder (no HTTP parsing)
Accept a client connection
Open a connection to upstream
Pipe bytes both ways until one side closes
âœ… Done when: curl through it works for simple GET.
What you learn: streaming + backpressure + half-close issues.

Milestone B (8â€“10h): HTTP request parsing + rewriting
Parse request headers
Rewrite:
Host to upstream host
add X-Forwarded-For
optionally force Connection: close to simplify early
âœ… Done when: you can route based on path later, and logs show method/path.
What you learn: parsing, header normalization, security limits.

Milestone C (6â€“8h): timeouts + basic protections
Header read timeout (slowloris defense)
Max header bytes (e.g. 32KB)
Upstream connect timeout + response inactivity timeout
âœ… Done when: a â€œhanging upstreamâ€ doesnâ€™t hang your server forever.

Milestone D (6â€“8h): simple routing + health checks
Route /api/* to upstream A, /static/* to upstream B
Background task: periodic GET /health
If unhealthy, return 503 immediately
âœ… Done when: killing upstream flips health within N seconds.

Milestone E (4â€“6h): observability
JSON logs: request_id, upstream, latency_ms, bytes_in/out, error
/metrics endpoint: counters + simple latency buckets
âœ… Done when: you can see request counts and failures.

â€œCool to show offâ€ bonus (optional if time remains)
Pick ONE:
Connection pooling (reuse upstream connections) â†’ teaches a lot
Least-connections balancing (if you add multiple upstreams)
Tiny in-memory cache for GET with TTL

ğŸ§  Python Networking & Sockets
ğŸ“Œ Beginner-friendly tutorial

ğŸ‘‰ Python Socket Programming (guide) â€” a solid intro to TCP sockets, servers, clients, and how Pythonâ€™s socket API works.
Great for grasping the basics: how connections work, how to send/receive bytes, etc.
https://realpython.com/python-sockets/?utm_source=chatgpt.com

ğŸŒ€ Async I/O with Python
ğŸ“Œ Official Python docs

ğŸ‘‰ asyncio streams documentation â€” shows how to build TCP clients/servers with asyncio, the primitives (StreamReader/StreamWriter) youâ€™ll use in your project.
This is exactly the level youâ€™ll need for writing your proxy with async networking.
https://docs.python.org/3/library/asyncio-stream.html?utm_source=chatgpt.com

ğŸŒ HTTP Protocol Deep Dives
ğŸ“Œ Build from scratch

ğŸ‘‰ HTTP from scratch with Python sockets â€” a guide (blog) that walks through sending/parsing raw HTTP requests and responses.
Useful for learning how HTTP messages are structured and processed under the hood.
https://hakk.dev/blog/posts/http-from-scratch-python-sockets/?utm_source=chatgpt.com

ğŸ§© Proxies & HTTP Concepts
ğŸ“Œ Concept overview

ğŸ‘‰ Proxies, reverse proxies, load balancers â€” explains what they are and the differences between forward vs reverse proxies at a high level.
Good for understanding why proxies exist and what theyâ€™re used for.
https://medium.com/%40nomannayeem/proxies-reverse-proxies-and-load-balancers-simplifying-web-traffic-like-a-pro-4d48bc1400b5

ğŸ“š Web Server Foundations
ğŸ“Œ Web server internals

ğŸ‘‰ Building a web server from scratch (series) â€” although not a proxy tutorial, it teaches how to design and implement HTTP handling from first principles.
That background will give you deeper context before you start proxy code.
https://dev.to/dmytro_huz/building-your-own-web-server-part-1-theory-and-foundations-3kgo?utm_source=chatgpt.com

ğŸ¥ (Optional) Video Resource
ğŸ“Œ Async server explained

Thereâ€™s a YouTube tutorial showing how to write an async server socket in Python â€” useful if you like seeing code in action.
https://www.youtube.com/watch?v=KFRi5ruK90I

ğŸ”­ Extra advanced options (if you want them)

Twisted networking framework â€” if later you want to explore another event-driven approach in Python.

Squid proxy â€” a real world C++ proxy you can study as reference.

ğŸ§  Suggested study order

Python sockets basics â€” server, client, recv/send.

asyncio streams â€” listen, accept, read/write concurrently.

HTTP structure & parsing â€” requests, headers, bodies.

Proxy concepts â€” forward vs reverse, routing.

Build tiny echo server/client â†’ simple HTTP parser â†’ proxy basics.



Books on the topic:
ğŸ“š How to Use These Together

Hereâ€™s a progression that works well for your project:

Start with HTTP basics
â€” High Performance Browser Networking or the HTTP parts of HTTP: The Definitive Guide

Build strong socket fundamentals
â€” UNIX Network Programming

Apply it in Python
â€” Python Network Programming Cookbook

Deepen your systems awareness
â€” Systems Performance
